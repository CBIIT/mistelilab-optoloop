---
title: "DNA FISH spots distance & cell-to-cell variability calculations"
author: "Martin Stortz/Gianluca Pegoraro"
date: today
date-format: long
format: 
  html:
      self-contained: true
      code-fold: true
      code-tools: true
      code-link: true
editor: source
---

###Load packages
```{r}
#| label: load-packages
#| include: false
#| warning: false

library(tidyverse)
library(fs)
library(data.table)
library(ggthemes)
library(SpatialTools)
```

### User variables input and settings specification
```{r input-variables}
GLOB_C <- "*nuclei_information_well*" # Pattern for Single Cell data files
GLOB_S <- "*spots_locations_well*" # Pattern for Single Spot data files

XY_RES <- 0.108 #pixel size in um
```

### Metadata: Experimental conditions and plate layout
Provide experimental conditions and plate layout
```{r}
#| label: metadata

#Provide experimental conditions in desired order:
light_levs <- c("Dark","Light","RNA-Dark","RNA-Light") 

plate_layout <- tibble(
  row = c(9L,9L,9L,9L),
  column = c(5L, 6L, 19L, 20L),
  well_index = c("I5","I6","I19","I20"),
  light = c("Dark","RNA-Dark","Light","RNA-Light")
) %>%
  mutate(light = factor(light, levels = light_levs))
```

###Download data if needed
```{r}
#| label: download


```

###### Read cells and spots data
HITIPS output text files must be in the `data` directory and the file names must match the GLOB pattern.

### Read cells data
```{r}
#| label: read-cells

cell_tbl <- dir_info("data", 
                     recurse = T, 
                     glob = GLOB_C) %>%
  filter(size > "1K") %>%
  rowwise() %>%
  reframe(fread(path), file_name = as.character(path)) %>%
  mutate(well_index = paste0(LETTERS[row], column)) %>%
  select(file_name, column, row, well_index,
         field_index, time_point, cell_index,
         area, solidity,
         x = `centroid-0`,
         y = `centroid-1`) %>%
  arrange(column, row, field_index,
          time_point, cell_index) %>%
  left_join(plate_layout, by = c("well_index", "row", "column"))

cell_tbl <- cell_tbl[!is.na(cell_tbl$light), ]  
```

Read and process the spot level data. Convert the x, y and z coordinates to microns (They were originally calculated in pixels) and filter spots that do not belong to any nucleus. These have a `cell_index` value of `0`.

### Read spots data
```{r}
#| label: read-spots

spots_tbl <- dir_info("data", 
                     recurse = T, 
                     glob = GLOB_S) %>%
  filter(size > "1K") %>%
  rowwise() %>%
  reframe(fread(path), file_name = as.character(path)) %>%
  mutate(well_index = paste0(LETTERS[row], column)) %>%
  select(file_name, column, row, 
         well_index, field_index, time_point, 
         cell_index,  channel, spot_index = V1,
         x = x_location, y = y_location) %>%
  #Convert xy distances from pixels to microns
  mutate(across(x:y, list(mic = ~ .x * XY_RES))) %>%
  #Filter out spots not in any nucleus
  filter(cell_index != 0) %>%
  arrange(column, row, field_index,
          time_point, cell_index, channel) %>%
  left_join(plate_layout, by = c("well_index", "row", "column"))

spots_tbl <- spots_tbl[!is.na(spots_tbl$light), ]  
```

### Filter cells by size and shape
```{r}
#| label: cell-filter

cell_filter_tbl <- cell_tbl %>%
  filter(area >= 50, solidity >= 0.875)
```

### Spot number per cell calculations
```{r}
#| label: calc-n-spots

cell_n_spots_tbl <- spots_tbl %>%
  group_by(column, row, well_index, light, field_index,
           time_point, cell_index, channel) %>%
  count() %>%
  pivot_wider(names_from = channel,
              names_prefix = "n_spots_channel_",
              values_from = n,
              values_fill = 0) %>%
  ungroup()
```

### Filter cells by spot number
```{r}
#| label: filter-spots
#| 
spot_filt_criterion <- quote(n_spots_channel_3 > 2 & n_spots_channel_2 == n_spots_channel_3) #set criterion for filtering

cell_n_spots_filt_tbl <- cell_n_spots_tbl %>%
  semi_join(cell_filter_tbl, by = c("row", "column", "well_index", "light", "field_index",
                             "time_point", "cell_index")) %>%
  filter(!!spot_filt_criterion)
```

### Filter out spots according to previous cell filtering by size, shape and spot number
```{r}
#| label: filter-spots-2

spot_filt_tbl <- spots_tbl %>% 
  semi_join(cell_n_spots_filt_tbl, 
            by = c("column", "row", "field_index", "light",
                   "time_point", "cell_index")) %>%
  as.data.table()
```

*2D Spot distance calculations*

###Calculate distances between all possible spot pairs for each cell
```{r}
#| label: calc-spot-dist

gf_dist_2D <- spot_filt_tbl[channel %in% 2:3, # Only  Red and Green spots
                              reshape2::melt(SpatialTools::dist2(as.matrix(.SD[channel == 2,
                                                       list(x_mic,y_mic)]),
                                         as.matrix(.SD[channel == 3,
                                                       list(x_mic,y_mic)])),
                                   value.name = "gf_dist"),
                          by = list(row, 
                                    column,
                                    well_index,
                                    light,
                                    field_index, 
                                    time_point, 
                                    cell_index)]

setnames(gf_dist_2D, c("Var1","Var2"), c("g_index","f_index"))
```

###Find minimum spot distance
Minimum distance is calculated based on channel 3 spots as reference
```{r}
#| label: proximity-green-farred

setkey(gf_dist_2D, row, column, well_index,
       field_index, time_point, cell_index, f_index)

gf_dist_min_2D <- gf_dist_2D[, .SD[which.min(gf_dist),], 
                        by = key(gf_dist_2D)] %>%
  left_join(select(cell_tbl, column:well_index, light, field_index:area),
            by = c("column", "row",
                   "well_index", "light", "field_index",
                   "time_point", "cell_index")) %>%
  #Filter out distances > 2 um
  filter(gf_dist <= 2)
```
###Analysis of cell-to-cell contact variability

#Calculate observed distributions
```{r}
#| label: observed-distributions

#Keep only cells with 3 alleles per cell
gf_dist_tri <- gf_dist_min_2D %>%
  group_by(light, field_index, time_point, cell_index) %>%
  filter(n() == 3) %>%
  ungroup()

#Pivot distances so each cell has gf_dist_1, gf_dist_2, gf_dist_3
gf_dist_wide <- gf_dist_tri %>%
  group_by(light, field_index, time_point, cell_index) %>%
  mutate(spot_id = paste0("gf_dist_", row_number())) %>%
  select(light, field_index, time_point, cell_index, spot_id, gf_dist) %>%
  pivot_wider(names_from = spot_id, values_from = gf_dist) %>%
  drop_na(gf_dist_1, gf_dist_2, gf_dist_3)  # Ensure no NAs

#Classify cells according to distances
gf_dist_classified <- gf_dist_wide %>%
  group_by(light, field_index, time_point, cell_index) %>%
  summarise(
    n_close = sum(gf_dist_1 < 0.27)+sum(gf_dist_2 < 0.27)+sum(gf_dist_3 < 0.27),
    .groups = "drop"
  ) %>%
  mutate(
    category = case_when(
      n_close == 3 ~ "All close",
      n_close == 2 ~ "Two close",
      n_close == 1 ~ "One close",
      n_close == 0 ~ "All distant"
    )
  )
observed_distr <- gf_dist_classified %>%
  group_by(light, category) %>%
  summarise(n_observed = n(), .groups = "drop") %>%
  group_by(light) %>%
  mutate(fraction_observed = n_observed / sum(n_observed))
```

#Calculate expected distributions assuming complete allele independence
```{r}
#| label: expected-distributions

# Count all distances per condition
allele_freqs <- gf_dist_min_2D %>%
  group_by(light) %>%
  summarise(
    n_alleles = n(),
    n_close = sum(gf_dist < 0.27),
    p_close = n_close / n_alleles,
    .groups = "drop"
  )


# Get expected counts 
expected_distr <- allele_freqs %>%
  mutate(
    all_close = p_close^3,
    two_close = 3 * p_close^2 * (1 - p_close),
    one_close = 3 * p_close * (1 - p_close)^2,
    all_distant = (1 - p_close)^3
  ) %>%
  pivot_longer(cols = c(all_close, two_close, one_close, all_distant),
               names_to = "category_raw",
               values_to = "expected_fraction") %>%
  mutate(
    category = case_when(
      category_raw == "all_close" ~ "All close",
      category_raw == "two_close" ~ "Two close",
      category_raw == "one_close" ~ "One close",
      category_raw == "all_distant" ~ "All distant"
    ),
    n_expected = expected_fraction * n_alleles / 3   # divide by 3 because each cell has 3 alleles
  ) %>%
  select(light, category, n_expected, expected_fraction)
```

### Chi-square test comparing observed vs expected
```{r}
#| label: chi-square

# Merge observed and expected
chi_data <- observed_distr %>%
  inner_join(expected_distr, by = c("light", "category"))

# Run chi-square test separately for each condition
chi_results <- chi_data %>%
  group_by(light) %>%
  summarise(
    chisq_test = list(
      chisq.test(
        x = n_observed,
        p = n_expected / sum(n_expected),
        rescale.p = TRUE
      )
    ),
    .groups = "drop"
  )

# Extract test results
chi_results_summary <- chi_results %>%
  mutate(
    statistic = map_dbl(chisq_test, "statistic"),
    df = map_dbl(chisq_test, "parameter"),
    p_value = map_dbl(chisq_test, "p.value")
  ) %>%
  select(light, statistic, df, p_value)
```

#Write output files
```{r}
#| label: write-csv

write.csv(chi_results_summary, "output/chi_results_summary.csv", row.names = FALSE)
write.csv(observed_distr, "output/observed_distr_summary.csv", row.names = FALSE)
write.csv(expected_distr, "output/expected_distr_summary.csv", row.names = FALSE)
```


### Session info
```{r}
#| label: session-info
#| results: markup

sessionInfo()
```

